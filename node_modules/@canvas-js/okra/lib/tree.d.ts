import type { Metadata, Key, Node, KeyValueStore, Target, Bound, Source } from "./interface.js";
import { NodeStore } from "./store.js";
export declare class Tree extends NodeStore implements KeyValueStore, Source, Target {
    readonly store: KeyValueStore;
    private static leafEntryLowerBound;
    private static leafEntryUpperBound;
    private static indent;
    private depth;
    private newSiblings;
    private readonly format;
    protected constructor(store: KeyValueStore, options?: Partial<Metadata>);
    entries(lowerBound?: Bound<Uint8Array> | null, upperBound?: Bound<Uint8Array> | null, { reverse }?: {
        reverse?: boolean;
    }): AsyncIterableIterator<[Uint8Array, Uint8Array]>;
    get(key: Uint8Array): Promise<Uint8Array | null>;
    set(key: Uint8Array, value: Uint8Array): Promise<void>;
    delete(key: Uint8Array): Promise<void>;
    private apply;
    private applyLeaf;
    private applyNode;
    private promote;
    private findTarget;
    private moveToPreviousChild;
    private hashNode;
    private getLastNode;
    private log;
    /**
     * Get the root node of the merkle tree. Returns the leaf anchor node if the tree is empty.
     */
    getRoot(): Promise<Node>;
    /**
     * Get the children of a node in the merkle tree, identified by level and key.
     */
    getChildren(level: number, key: Key): Promise<Node[]>;
    /**
     * Raze and rebuild the merkle tree from the leaves.
     * @returns the new root node
     */
    rebuild(): Promise<Node>;
    /**
     * Pretty-print the tree structure to a utf-8 stream.
     * Consume with a TextDecoderStream or async iterable sink.
     */
    print(options?: {
        hashSize?: number;
    }): AsyncIterableIterator<Uint8Array>;
}
//# sourceMappingURL=tree.d.ts.map