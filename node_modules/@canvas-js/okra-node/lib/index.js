import assert from "node:assert";
import { createRequire } from "node:module";
import { familySync } from "detect-libc";
import { equals } from "uint8arrays";
import PQueue from "p-queue";
import { lessThan } from "@canvas-js/okra";
const family = familySync();
const { platform, arch } = process;
const target = family === null ? `${arch}-${platform}` : `${arch}-${platform}-${family}`;
const require = createRequire(import.meta.url);
const okra = require(`../build/${target}/okra.node`);
export class Environment extends okra.Environment {
    path;
    #open = true;
    #queue = new PQueue({ concurrency: 1 });
    constructor(path, options = {}) {
        super(path, options);
        this.path = path;
    }
    async close() {
        this.#queue.clear();
        await this.#queue.onIdle();
        if (this.#open) {
            super.close();
            this.#open = false;
        }
        else {
            throw new Error("environment closed");
        }
    }
    async resize(mapSize) {
        await this.#queue.add(() => super.resize(mapSize));
    }
    async read(callback, options = {}) {
        const txn = new Transaction(this, { ...options, readOnly: true });
        try {
            return await callback(txn);
        }
        finally {
            txn.abort();
        }
    }
    readTree(callback, options = {}) {
        return this.read(async (txn) => {
            const tree = new Tree(txn, options);
            try {
                return await callback(tree);
            }
            finally {
                tree.close();
            }
        });
    }
    async write(callback, options = {}) {
        let result = null;
        await this.#queue.add(async () => {
            const txn = new Transaction(this, { ...options, readOnly: false });
            try {
                result = await callback(txn);
                txn.commit();
            }
            catch (err) {
                txn.abort();
                throw err;
            }
        });
        return result;
    }
    writeTree(callback, options = {}) {
        return this.write(async (txn) => {
            const tree = new Tree(txn, options);
            try {
                return await callback(tree);
            }
            finally {
                tree.close();
            }
        });
    }
}
export class Transaction extends okra.Transaction {
    env;
    readOnly;
    parent;
    #open = true;
    #dbi;
    constructor(env, options = {}) {
        const readOnly = options.readOnly ?? false;
        const parent = options.parent ?? null;
        super(env, readOnly, parent);
        this.env = env;
        this.readOnly = readOnly;
        this.parent = parent;
        this.#dbi = typeof options.dbi === "number" ? options.dbi : this.openDatabase(options.dbi ?? null);
    }
    openDatabase(dbi) {
        return super.openDatabase(dbi);
    }
    abort() {
        if (this.#open) {
            super.abort();
            this.#open = false;
        }
        else {
            throw new Error("transaction closed");
        }
    }
    commit() {
        if (this.#open) {
            super.commit();
            this.#open = false;
        }
        else {
            throw new Error("transaction closed");
        }
    }
    get(key, options = {}) {
        const dbi = options.dbi ?? this.#dbi;
        return super.get(dbi, key);
    }
    set(key, value, options = {}) {
        const dbi = options.dbi ?? this.#dbi;
        super.set(dbi, key, value);
    }
    delete(key, options = {}) {
        const dbi = options.dbi ?? this.#dbi;
        if (super.get(dbi, key) !== null) {
            super.delete(dbi, key);
        }
    }
    async *entries(lowerBound = null, upperBound = null, options = {}) {
        const { dbi = null, reverse = false } = options;
        const cursor = new Cursor(this, { dbi });
        if (reverse) {
            for (let key = cursor.goToEnd(upperBound); key !== null; key = cursor.goToPrevious()) {
                if (lowerBound !== null) {
                    if (lessThan(key, lowerBound.key)) {
                        return;
                    }
                    else if (lowerBound.inclusive === false && equals(lowerBound.key, key)) {
                        return;
                    }
                }
                const value = cursor.getCurrentValue();
                yield [key, value];
            }
        }
        else {
            for (let key = cursor.goToStart(lowerBound); key !== null; key = cursor.goToNext()) {
                if (upperBound !== null) {
                    if (lessThan(upperBound.key, key)) {
                        return;
                    }
                    else if (upperBound.inclusive === false && equals(upperBound.key, key)) {
                        return;
                    }
                }
                const value = cursor.getCurrentValue();
                yield [key, value];
            }
        }
    }
}
export class Cursor extends okra.Cursor {
    txn;
    dbi;
    #open = true;
    constructor(txn, options = {}) {
        const dbi = typeof options.dbi === "number" ? options.dbi : txn.openDatabase(options.dbi ?? null);
        super(txn, dbi);
        this.txn = txn;
        this.dbi = dbi;
    }
    close() {
        if (this.#open) {
            super.close();
            this.#open = false;
        }
        else {
            throw new Error("cursor closed");
        }
    }
    goToStart(lowerBound) {
        if (lowerBound === null) {
            return this.goToFirst();
        }
        const start = this.seek(lowerBound.key);
        if (lowerBound.inclusive === false) {
            if (start !== null && equals(start, lowerBound.key)) {
                return this.goToNext();
            }
        }
        return start;
    }
    goToEnd(upperBound) {
        if (upperBound === null) {
            return this.goToLast();
        }
        const end = this.seek(upperBound.key);
        if (upperBound.inclusive) {
            if (end !== null && equals(end, upperBound.key)) {
                return end;
            }
            else {
                return this.goToPrevious();
            }
        }
        else {
            return this.goToPrevious();
        }
    }
    getCurrentEntry() {
        const [key, value] = super.getCurrentEntry();
        return [key, value];
    }
    getCurrentKey() {
        return super.getCurrentKey();
    }
    getCurrentValue() {
        return super.getCurrentValue();
    }
    setCurrentValue(value) {
        super.setCurrentValue(value);
    }
    deleteCurrentKey() {
        super.deleteCurrentKey();
    }
    goToNext() {
        return super.goToNext();
    }
    goToPrevious() {
        return super.goToPrevious();
    }
    goToFirst() {
        return super.goToFirst();
    }
    goToLast() {
        return super.goToLast();
    }
    goToKey(key) {
        super.goToKey(key);
    }
    seek(needle) {
        return super.seek(needle);
    }
}
export class Tree extends okra.Tree {
    txn;
    dbi;
    #open = true;
    constructor(txn, options = {}) {
        const dbi = typeof options.dbi === "number" ? options.dbi : txn.openDatabase(options.dbi ?? null);
        super(txn, dbi);
        this.txn = txn;
        this.dbi = dbi;
    }
    close() {
        if (this.#open) {
            super.close();
            this.#open = false;
        }
        else {
            throw new Error("tree closed");
        }
    }
    // KeyValueStore methods
    get(key) {
        return super.get(key);
    }
    set(key, value) {
        super.set(key, value);
    }
    delete(key) {
        super.delete(key);
    }
    async *entries(lowerBound = null, upperBound = null, options = {}) {
        for await (const node of this.nodes(0, lowerBound ?? { key: null, inclusive: false }, upperBound, options)) {
            assert(node.key !== null, "expected node.key !== null");
            assert(node.value !== undefined, "expected node.value !== undefined");
            yield [node.key, node.value];
        }
    }
    // Source & Target methods
    getRoot() {
        return super.getRoot();
    }
    getNode(level, key) {
        return super.getNode(level, key);
    }
    getChildren(level, key) {
        return super.getChildren(level, key);
    }
    async *nodes(level, lowerBound = null, upperBound = null, options = {}) {
        const iter = new Iterator(this, level, lowerBound, upperBound, options);
        try {
            for (let node = iter.next(); node !== null; node = iter.next()) {
                yield node;
            }
        }
        finally {
            iter.close();
        }
    }
}
export class Iterator extends okra.Iterator {
    tree;
    #open = true;
    constructor(tree, level, lowerBound = null, upperBound = null, options = {}) {
        super(tree, level, lowerBound, upperBound, options.reverse ?? false);
        this.tree = tree;
    }
    close() {
        if (this.#open) {
            super.close();
            this.#open = false;
        }
        else {
            throw new Error("iterator closed");
        }
    }
    next() {
        return super.next();
    }
}
