var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _SyncService_controller, _SyncService_registrarId;
import { logger } from "@libp2p/logger";
import PQueue from "p-queue";
import * as lp from "it-length-prefixed";
import { pipe } from "it-pipe";
import { bytesToHex as hex } from "@noble/hashes/utils";
import { Client, Server, decodeRequests, encodeResponses } from "./index.js";
import { MAX_CONNECTIONS, MAX_INBOUND_STREAMS, MAX_OUTBOUND_STREAMS, MAX_SYNC_QUEUE_SIZE, MIN_CONNECTIONS, SYNC_COOLDOWN_PERIOD, SYNC_RETRY_INTERVAL, SYNC_RETRY_LIMIT, second, } from "../constants.js";
import { CacheMap, shuffle, sortPair, wait, DelayableController, SyncDeadlockError, SyncTimeoutError, } from "../utils.js";
import { anySignal } from "any-signal";
/**
 * The SyncService class implements a libp2p syncing service for GossipLog messages.
 * The service is configured with a global "topic" and takes place over a libp2p protocol
 * interpolating that topic (`/canvas/sync/v1/${init.topic}`). By default, it schedules
 * a merkle sync for every new connection with a peer supporting the same topic.
 */
export class SyncService {
    constructor(components, messages, options) {
        this.components = components;
        this.messages = messages;
        this.topologyPeers = new Set();
        this.syncQueue = new PQueue({ concurrency: 1 });
        this.syncQueuePeers = new Set();
        this.syncHistory = new CacheMap(MAX_SYNC_QUEUE_SIZE);
        _SyncService_controller.set(this, new AbortController());
        _SyncService_registrarId.set(this, null);
        this.handleIncomingStream = async ({ connection, stream }) => {
            const peerId = connection.remotePeer;
            if (this.messages.open === false) {
                this.log("aborted incoming stream %s from peer %p", stream.id, peerId);
                stream.abort(new Error("application was closed"));
                return;
            }
            this.log("opened incoming stream %s from peer %p", stream.id, peerId);
            const timeoutController = new DelayableController(3 * second);
            const signal = anySignal([__classPrivateFieldGet(this, _SyncService_controller, "f").signal, timeoutController.signal]);
            signal.addEventListener("abort", (err) => {
                if (stream.status === "open") {
                    stream.abort(new Error("TIMEOUT"));
                }
            });
            try {
                await this.messages.serve(async (source) => {
                    const server = new Server(source);
                    await pipe(stream.source, lp.decode, decodeRequests, (reqs) => {
                        timeoutController.delay();
                        return server.handle(reqs);
                    }, encodeResponses, lp.encode, stream.sink);
                }, { targetId: peerId.toString() });
                this.log("closed incoming stream %s from peer %p", stream.id, peerId);
            }
            catch (err) {
                this.log.error("aborting incoming stream %s from peer %p: %s: %s", stream.id, peerId, err?.name, err?.message);
                if (err instanceof Error) {
                    stream.abort(err);
                }
                else {
                    stream.abort(new Error("internal error"));
                }
            }
            finally {
                signal.clear();
            }
        };
        this.log = logger(`canvas:gossiplog:[${this.topic}]:sync`);
        this.protocol = `/gossiplog/sync/v1/${messages.topic}`;
        this.maxInboundStreams = options.maxInboundStreams ?? MAX_INBOUND_STREAMS;
        this.maxOutboundStreams = options.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
        this.minConnections = options.minConnections ?? MIN_CONNECTIONS;
        this.maxConnections = options.maxConnections ?? MAX_CONNECTIONS;
    }
    isStarted() {
        return __classPrivateFieldGet(this, _SyncService_registrarId, "f") !== null;
    }
    get topic() {
        return this.messages.topic;
    }
    async start() {
        this.log("starting sync service");
        await this.components.registrar.handle(this.protocol, this.handleIncomingStream, {
            maxInboundStreams: this.maxInboundStreams,
            maxOutboundStreams: this.maxOutboundStreams,
        });
        __classPrivateFieldSet(this, _SyncService_registrarId, await this.components.registrar.register(this.protocol, {
            min: this.minConnections,
            max: this.maxConnections,
            onConnect: (peerId, connection) => {
                this.topologyPeers.add(peerId.toString());
                this.log("connected to peer %p", peerId);
                this.scheduleSync(peerId);
            },
            onDisconnect: (peerId) => {
                this.log("disconnected from %p", peerId);
                this.topologyPeers.delete(peerId.toString());
            },
        }), "f");
    }
    async stop() {
        if (__classPrivateFieldGet(this, _SyncService_registrarId, "f") === null) {
            return;
        }
        this.log("stopping sync service");
        __classPrivateFieldGet(this, _SyncService_controller, "f").abort();
        this.syncQueue.clear();
        await this.syncQueue.onIdle();
        await this.components.registrar.unhandle(this.protocol);
        if (__classPrivateFieldGet(this, _SyncService_registrarId, "f") !== null) {
            this.components.registrar.unregister(__classPrivateFieldGet(this, _SyncService_registrarId, "f"));
            __classPrivateFieldSet(this, _SyncService_registrarId, null, "f");
        }
    }
    scheduleSync(peerId) {
        const id = peerId.toString();
        if (this.syncQueuePeers.has(id)) {
            this.log("already queued sync with %p", peerId);
            return;
        }
        if (this.syncQueue.size >= MAX_SYNC_QUEUE_SIZE) {
            this.log("sync queue is full", this.topic);
            return;
        }
        const lastSyncMark = this.syncHistory.get(id);
        if (lastSyncMark !== undefined) {
            const timeSinceLastSync = performance.now() - lastSyncMark;
            this.log("last sync with %p was %ds ago", peerId, Math.floor(timeSinceLastSync / 1000));
            if (timeSinceLastSync < SYNC_COOLDOWN_PERIOD) {
                return;
            }
        }
        this.syncQueuePeers.add(id);
        this.syncQueue
            .add(async () => {
            // having one peer wait an initial randomized interval
            // reduces the likelihood of deadlock to near-zero,
            // but it could still happen.
            // comment out this block to test the deadlock recovery process.
            const [x, y] = sortPair(this.components.peerId, peerId);
            if (x.equals(this.components.peerId)) {
                const interval = Math.floor(Math.random() * SYNC_RETRY_INTERVAL);
                this.log("waiting an initial %dms", interval);
                await this.wait(interval);
            }
            for (let n = 0; n < SYNC_RETRY_LIMIT; n++) {
                try {
                    this.log("dialing %p:", peerId);
                    const stream = await this.dial(peerId);
                    if (stream === null) {
                        throw new Error("failed to open stream with " + peerId.toString());
                    }
                    return await this.sync(peerId, stream);
                }
                catch (err) {
                    if (err instanceof SyncTimeoutError) {
                        this.log("merkle sync timed out with %p, waiting to continue", peerId);
                    }
                    else if (err instanceof SyncDeadlockError) {
                        this.log("started merkle sync concurrently with %p, retrying to break deadlock", peerId);
                    }
                    else {
                        this.log.error("failed to sync with peer %p: %s: %s", peerId, err?.name, err?.message);
                    }
                    if (__classPrivateFieldGet(this, _SyncService_controller, "f").signal.aborted) {
                        break;
                    }
                    else {
                        const interval = Math.floor(Math.random() * SYNC_RETRY_INTERVAL);
                        this.log("waiting %dms before trying again (%d/%d)", interval, n + 1, SYNC_RETRY_LIMIT);
                        await this.wait(interval);
                        continue;
                    }
                }
            }
            throw new Error("exceeded sync retry limit: " + peerId.toString());
        })
            .then(() => this.syncHistory.set(id, performance.now()))
            .catch((err) => this.log.error("sync failed: %O", err.message))
            .finally(() => this.syncQueuePeers.delete(id));
    }
    async sync(peerId, stream) {
        const timeoutController = new DelayableController(3 * second);
        const signal = anySignal([__classPrivateFieldGet(this, _SyncService_controller, "f").signal, timeoutController.signal]);
        signal.addEventListener("abort", (err) => {
            if (stream.status === "open") {
                stream.abort(new Error("TIMEOUT"));
            }
        });
        const client = new Client(stream);
        try {
            this.log("initiating sync with peer %p", peerId);
            const { root, messageCount } = await this.messages.sync(client, {
                sourceId: peerId.toString(),
                timeoutController,
            });
            this.log("finished sync with peer %p, got root hash %s (%s messages)", peerId, hex(root.hash), messageCount);
        }
        finally {
            signal.clear();
            client.end();
            this.log("closed outgoing stream %s to peer %p", stream.id, peerId);
        }
    }
    async dial(peerId) {
        const connections = [...this.components.connectionManager.getConnections(peerId)];
        if (connections.length === 0) {
            this.log("no longer connected to peer %p", peerId);
            return null;
        }
        // randomize selected connection
        shuffle(connections);
        for (const connection of connections) {
            if (connection.transient) {
                continue;
            }
            this.log("opening outgoing stream on connection %s", connection.id);
            try {
                // TODO: figure out what { signal } does here - is it just for opening the stream or for its entire duration?
                const stream = await connection.newStream(this.protocol);
                this.log("opened outgoing stream %s to peer %p", stream.id, peerId);
                return stream;
            }
            catch (err) {
                this.log.error("failed to open outgoing stream: %O", err);
                continue;
            }
        }
        return null;
    }
    async wait(interval) {
        await wait(interval, { signal: __classPrivateFieldGet(this, _SyncService_controller, "f").signal });
    }
}
_SyncService_controller = new WeakMap(), _SyncService_registrarId = new WeakMap();
