import { Startable, PeerId, Connection, StreamHandler, StreamHandlerOptions } from "@libp2p/interface";
import { AbstractGossipLog } from "../AbstractGossipLog.js";
export interface Topology {
    min?: number;
    max?: number;
    onConnect?: (peerId: PeerId, conn: Connection) => void;
    onDisconnect?: (peerId: PeerId) => void;
}
export interface SyncOptions {
    minConnections?: number;
    maxConnections?: number;
    maxInboundStreams?: number;
    maxOutboundStreams?: number;
}
export interface SyncServiceComponents {
    peerId: PeerId;
    registrar: {
        handle: (protocol: string, handler: StreamHandler, options?: StreamHandlerOptions | undefined) => Promise<void>;
        register: (protocol: string, topology: Topology) => Promise<string>;
        unhandle: (protocol: string) => Promise<void>;
        unregister: (id: string) => void;
    };
    connectionManager: {
        getConnections: (peerId?: PeerId | undefined) => Connection[];
    };
}
/**
 * The SyncService class implements a libp2p syncing service for GossipLog messages.
 * The service is configured with a global "topic" and takes place over a libp2p protocol
 * interpolating that topic (`/canvas/sync/v1/${init.topic}`). By default, it schedules
 * a merkle sync for every new connection with a peer supporting the same topic.
 */
export declare class SyncService<Payload = unknown, Result = void> implements Startable {
    #private;
    private readonly components;
    private readonly messages;
    private readonly protocol;
    private readonly topologyPeers;
    private readonly maxInboundStreams;
    private readonly maxOutboundStreams;
    private readonly minConnections;
    private readonly maxConnections;
    private readonly syncQueue;
    private readonly syncQueuePeers;
    private readonly syncHistory;
    private readonly log;
    constructor(components: SyncServiceComponents, messages: AbstractGossipLog<Payload, Result>, options: SyncOptions);
    isStarted(): boolean;
    get topic(): string;
    start(): Promise<void>;
    stop(): Promise<void>;
    private handleIncomingStream;
    private scheduleSync;
    private sync;
    private dial;
    private wait;
}
