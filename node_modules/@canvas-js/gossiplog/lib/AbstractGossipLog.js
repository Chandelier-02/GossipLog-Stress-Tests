var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractGossipLog_instances, _AbstractGossipLog_transformer, _AbstractGossipLog_apply, _AbstractGossipLog_getAncestors, _AbstractGossipLog_insert;
import { TypedEventEmitter, CustomEvent } from "@libp2p/interface";
import { logger } from "@libp2p/logger";
import * as cbor from "@ipld/dag-cbor";
import { fromDSL } from "@ipld/schema/from-dsl.js";
import { create } from "@ipld/schema/typed.js";
import { bytesToHex as hex } from "@noble/hashes/utils";
import { base58btc } from "multiformats/bases/base58";
import { equals } from "uint8arrays";
import { Ed25519Signer, didKeyPattern, getCID, verifySignature, verifySignedValue } from "@canvas-js/signed-cid";
import { Mempool } from "./Mempool.js";
import { Driver } from "./sync/driver.js";
import { decodeClock } from "./clock.js";
import { decodeId, encodeId, encodeSignedMessage, getNextClock, KEY_LENGTH, messageIdPattern, MIN_MESSAGE_ID, MAX_MESSAGE_ID, getKey, decodeSignedMessage, } from "./schema.js";
import { assert, topicPattern, cborNull, getAncestorClocks } from "./utils.js";
export class AbstractGossipLog extends TypedEventEmitter {
    constructor(init) {
        super();
        _AbstractGossipLog_instances.add(this);
        this.mempool = new Mempool();
        _AbstractGossipLog_transformer.set(this, void 0);
        _AbstractGossipLog_apply.set(this, void 0);
        assert(topicPattern.test(init.topic), "invalid topic (must match [a-zA-Z0-9\\.\\-])");
        this.topic = init.topic;
        this.open = true;
        __classPrivateFieldSet(this, _AbstractGossipLog_apply, init.apply, "f");
        if (typeof init.validate === "function") {
            const { validate } = init;
            __classPrivateFieldSet(this, _AbstractGossipLog_transformer, {
                toTyped: (obj) => (validate(obj) ? obj : undefined),
                toRepresentation: (obj) => (validate(obj) ? obj : undefined),
            }, "f");
        }
        else {
            const { schema, name } = init.validate;
            __classPrivateFieldSet(this, _AbstractGossipLog_transformer, create(typeof schema === "string" ? fromDSL(schema) : schema, name), "f");
        }
        this.indexAncestors = init.indexAncestors ?? false;
        this.signer = init.signer ?? new Ed25519Signer();
        this.log = logger(`canvas:gossiplog:[${this.topic}]`);
    }
    async replay() {
        await this.read(async (txn) => {
            for await (const [key, value] of txn.messages.entries()) {
                const [id, signature, message] = this.decode(value);
                assert(id === decodeId(key), "expected id === decodeId(key)");
                await __classPrivateFieldGet(this, _AbstractGossipLog_apply, "f").apply(txn, [id, signature, message]);
            }
        });
    }
    async *iterate(lowerBound = null, upperBound = null, options = {}) {
        const { id: lowerId, inclusive: lowerInclusive } = lowerBound ?? { id: MIN_MESSAGE_ID, inclusive: true };
        const { id: upperId, inclusive: upperInclusive } = upperBound ?? { id: MAX_MESSAGE_ID, inclusive: true };
        assert(messageIdPattern.test(lowerId), "lowerBound.id: invalid message ID");
        assert(messageIdPattern.test(upperId), "upperBound.id: invalid message ID");
        for await (const [key, value] of this.entries({ key: encodeId(lowerId), inclusive: lowerInclusive }, { key: encodeId(upperId), inclusive: upperInclusive }, options)) {
            const [id, signature, message] = this.decode(value);
            assert(id === decodeId(key), "expected id === decodeId(key)");
            yield [id, signature, message];
        }
    }
    encode(signature, message) {
        assert(message.topic === this.topic, "invalid message topic");
        const parents = message.parents.sort().map(encodeId);
        assert(getNextClock(parents) === message.clock, "error encoding message (invalid clock)");
        const payload = __classPrivateFieldGet(this, _AbstractGossipLog_transformer, "f").toRepresentation(message.payload);
        assert(payload !== undefined, "error encoding message (invalid payload)");
        const result = didKeyPattern.exec(signature.publicKey);
        assert(result !== null);
        const [{}, bytes] = result;
        const signedMessage = {
            publicKey: base58btc.decode(bytes),
            signature: signature.signature,
            parents: parents,
            payload: payload,
        };
        const value = encodeSignedMessage(signedMessage);
        const key = getKey(message.clock, value);
        return [key, value];
    }
    decode(value) {
        const signedMessage = decodeSignedMessage(value);
        const clock = getNextClock(signedMessage.parents);
        const parents = signedMessage.parents.map(decodeId);
        assert(parents.every((id, i) => i === 0 || parents[i - 1] < id), "unsorted parents array");
        const payload = __classPrivateFieldGet(this, _AbstractGossipLog_transformer, "f").toTyped(signedMessage.payload);
        assert(payload !== undefined, "error decoding message (invalid payload)");
        const message = { topic: this.topic, clock, parents, payload };
        const signature = {
            publicKey: `did:key:${base58btc.encode(signedMessage.publicKey)}`,
            signature: signedMessage.signature,
            cid: getCID(message, { codec: "dag-cbor", digest: "sha2-256" }),
        };
        const id = decodeId(getKey(clock, value));
        return [id, signature, message];
    }
    async getClock() {
        const heads = await this.read((txn) => this.getHeads(txn));
        const clock = getNextClock(heads);
        return [clock, heads.map(decodeId)];
    }
    async has(id) {
        assert(messageIdPattern.test(id), "invalid message ID");
        return await this.read(({ messages }) => messages.get(encodeId(id)) !== null);
    }
    async get(id) {
        assert(messageIdPattern.test(id), "invalid message ID");
        const value = await this.read(({ messages }) => messages.get(encodeId(id)));
        if (value === null) {
            return [null, null];
        }
        const [_, signature, message] = this.decode(value);
        return [signature, message];
    }
    async getHeads(txn) {
        const parents = [];
        for await (const [key, value] of txn.heads.entries()) {
            assert(key.byteLength === KEY_LENGTH, "internal error (expected key.byteLength === KEY_LENGTH)");
            assert(equals(value, cborNull), "internal error (unexpected parent entry value)");
            parents.push(key);
        }
        return parents;
    }
    /**
     * Sign and append a new *unsigned* message to the end of the log.
     * The currently unmerged heads of the local log are used as parents.
     */
    async append(payload, options = {}) {
        const signer = options.signer ?? this.signer;
        const { id, signature, message, result, root } = await this.write(async (txn) => {
            const heads = await this.getHeads(txn);
            const clock = getNextClock(heads);
            const parents = heads.map(decodeId);
            const message = { topic: this.topic, clock, parents, payload };
            const signature = await signer.sign(message);
            const [key, value] = this.encode(signature, message);
            const id = decodeId(key);
            this.log("appending message %s: %O", id, message);
            const result = await __classPrivateFieldGet(this, _AbstractGossipLog_instances, "m", _AbstractGossipLog_insert).call(this, txn, id, signature, message, [key, value]);
            const root = await txn.messages.getRoot();
            return { id, signature, message, result, root };
        });
        this.dispatchEvent(new CustomEvent("commit", { detail: { topic: this.topic, root } }));
        this.log("commited root %s", hex(root.hash));
        return { id, signature, message, result };
    }
    /**
     * Insert an existing signed message into the log (ie received via PubSub).
     * If any of the parents are not present, insert the message into the mempool instead.
     */
    async insert(signature, message) {
        verifySignedValue(signature, message);
        const { id, root } = await this.write(async (txn) => {
            const [key, value] = this.encode(signature, message);
            const id = decodeId(key);
            this.log("inserting message %s", id);
            const missingParents = new Set();
            this.log("looking up %s parents", message.parents.length);
            for (const parentId of message.parents) {
                const parent = await txn.messages.get(encodeId(parentId));
                if (parent === null) {
                    this.log("missing parent %s", parentId);
                    missingParents.add(parentId);
                }
                else {
                    this.log("found parent %s", parentId);
                }
            }
            if (missingParents.size > 0) {
                this.log("missing %d/%d parents", missingParents.size, message.parents.length);
                this.mempool.add(id, { signature, message }, missingParents);
                // If indexAncestors = false, execute the action, but add into the mempool in case
                // execution fails, e.g. it's an action with a session that has not been broadcast yet.
                // TODO: Clarify separation between indexAncestors and mempool for missing parents.
                if (this.indexAncestors) {
                    return { id };
                }
            }
            await __classPrivateFieldGet(this, _AbstractGossipLog_instances, "m", _AbstractGossipLog_insert).call(this, txn, id, signature, message, [key, value]);
            const root = await txn.messages.getRoot();
            return { id, root };
        });
        if (root !== undefined) {
            this.dispatchEvent(new CustomEvent("commit", { detail: { topic: this.topic, root } }));
            this.log("commited root %s", hex(root.hash));
        }
        return { id };
    }
    async getAncestors(id, atOrBefore) {
        assert(messageIdPattern.test(id), "invalid message ID");
        const results = new Set();
        await this.read((txn) => __classPrivateFieldGet(this, _AbstractGossipLog_instances, "m", _AbstractGossipLog_getAncestors).call(this, txn, encodeId(id), atOrBefore, results));
        this.log("getAncestors of %s atOrBefore %d: %o", id, atOrBefore, results);
        return Array.from(results).sort();
    }
    async isAncestor(id, ancestor) {
        assert(messageIdPattern.test(id), "invalid message ID");
        return await this.read((txn) => AbstractGossipLog.isAncestor(txn, id, ancestor));
    }
    static async isAncestor(txn, id, ancestor, visited = new Set()) {
        assert(txn.ancestors !== undefined, "expected txn.ancestors !== undefined");
        assert(messageIdPattern.test(id), "invalid message ID (id)");
        assert(messageIdPattern.test(ancestor), "invalid message ID (ancestor)");
        if (id === ancestor) {
            return true;
        }
        const ancestorKey = encodeId(ancestor);
        const [ancestorClock] = decodeClock(ancestorKey);
        const key = encodeId(id);
        const [clock] = decodeClock(key);
        if (clock <= ancestorClock) {
            return false;
        }
        const index = Math.floor(Math.log2(Number(clock - ancestorClock)));
        const value = await txn.ancestors.get(key);
        assert(value !== null, "key not found in ancestor index");
        const links = cbor.decode(value);
        for (const key of links[index]) {
            const id = decodeId(key);
            if (visited.has(id)) {
                continue;
            }
            visited.add(id);
            const isAncestor = await AbstractGossipLog.isAncestor(txn, id, ancestor, visited);
            if (isAncestor) {
                return true;
            }
        }
        return false;
    }
    /**
     * Sync with a remote source, applying and inserting all missing messages into the local log
     */
    async sync(source, options = {}) {
        let messageCount = 0;
        const start = performance.now();
        const root = await this.write(async (txn) => {
            const driver = new Driver(this.topic, source, txn.messages);
            for await (const [key, value] of driver.sync()) {
                const [id, signature, message] = this.decode(value);
                assert(id === decodeId(key), "expected id === decodeId(key)");
                verifySignature(signature);
                const existingMessage = await txn.messages.get(key);
                if (existingMessage === null) {
                    for (const parent of message.parents) {
                        const parentKey = encodeId(parent);
                        const parentValue = await txn.messages.get(parentKey);
                        if (parentValue === null) {
                            this.log.error("missing parent %s of message %s: %O", parent, id, message);
                            if (this.indexAncestors) {
                                throw new Error(`missing parent ${parent} of message ${id}`);
                            }
                            else {
                                continue; // don't try to insert, just skip and try to get the message on the next sync
                            }
                        }
                    }
                    await __classPrivateFieldGet(this, _AbstractGossipLog_instances, "m", _AbstractGossipLog_insert).call(this, txn, id, signature, message, [key, value]);
                    if (options.timeoutController)
                        options.timeoutController.delay();
                    messageCount++;
                }
            }
            return await txn.messages.getRoot();
        }, options);
        const duration = Math.ceil(performance.now() - start);
        const peer = options.sourceId;
        this.dispatchEvent(new CustomEvent("sync", { detail: { peer, duration, messageCount } }));
        this.dispatchEvent(new CustomEvent("commit", { detail: { root } }));
        this.log("commited root %s", hex(root.hash));
        return { root, messageCount };
    }
    /**
     * Serve a read-only snapshot of the merkle tree
     */
    async serve(callback, options = {}) {
        await this.read((txn) => callback(txn.messages), options);
    }
}
_AbstractGossipLog_transformer = new WeakMap(), _AbstractGossipLog_apply = new WeakMap(), _AbstractGossipLog_instances = new WeakSet(), _AbstractGossipLog_getAncestors = async function _AbstractGossipLog_getAncestors(txn, key, atOrBefore, results, visited = new Set()) {
    assert(txn.ancestors !== undefined, "expected txn.ancestors !== undefined");
    assert(atOrBefore > 0, "expected atOrBefore > 0");
    const [clock] = decodeClock(key);
    assert(atOrBefore < Number(clock), "expected atOrBefore < clock");
    const index = Math.floor(Math.log2(Number(clock) - atOrBefore));
    const value = await txn.ancestors.get(key);
    if (value === null) {
        throw new Error(`key ${decodeId(key)} not found in ancestor index`);
    }
    const links = cbor.decode(value);
    for (const ancestorKey of links[index]) {
        const [ancestorClock] = decodeClock(ancestorKey);
        const ancestorId = decodeId(ancestorKey);
        if (Number(ancestorClock) <= atOrBefore) {
            results.add(ancestorId);
        }
        else if (visited.has(ancestorId)) {
            return;
        }
        else {
            visited.add(ancestorId);
            await __classPrivateFieldGet(this, _AbstractGossipLog_instances, "m", _AbstractGossipLog_getAncestors).call(this, txn, ancestorKey, atOrBefore, results, visited);
        }
    }
}, _AbstractGossipLog_insert = async function _AbstractGossipLog_insert(txn, id, signature, message, [key, value] = this.encode(signature, message)) {
    this.log("applying %s %O", id, message);
    let result;
    try {
        result = await __classPrivateFieldGet(this, _AbstractGossipLog_apply, "f").apply(txn, [id, signature, message]);
    }
    catch (error) {
        this.dispatchEvent(new CustomEvent("error", { detail: { error } }));
        throw error;
    }
    this.dispatchEvent(new CustomEvent("message", { detail: { id, signature, message, result } }));
    await txn.messages.set(key, value);
    const parents = message.parents.map(encodeId);
    await txn.heads.set(key, cborNull);
    for (const parent of parents) {
        await txn.heads.delete(parent);
    }
    if (this.indexAncestors) {
        assert(txn.ancestors !== undefined, "expected txn.ancestors !== undefined");
        const ancestorClocks = Array.from(getAncestorClocks(message.clock));
        const ancestorLinks = new Array(ancestorClocks.length);
        for (const [i, ancestorClock] of ancestorClocks.entries()) {
            if (i === 0) {
                ancestorLinks[i] = parents;
            }
            else {
                const links = new Set();
                for (const child of ancestorLinks[i - 1]) {
                    const [childClock] = decodeClock(child);
                    if (Number(childClock) <= ancestorClock) {
                        links.add(decodeId(child));
                    }
                    else {
                        assert(Number(childClock) <= ancestorClocks[i - 1], "expected childClock <= ancestorClocks[i - 1]");
                        await __classPrivateFieldGet(this, _AbstractGossipLog_instances, "m", _AbstractGossipLog_getAncestors).call(this, txn, child, ancestorClock, links);
                    }
                }
                ancestorLinks[i] = Array.from(links).map(encodeId);
            }
        }
        await txn.ancestors.set(key, cbor.encode(ancestorLinks));
    }
    for (const [childId, signedMessage] of this.mempool.observe(id)) {
        await __classPrivateFieldGet(this, _AbstractGossipLog_instances, "m", _AbstractGossipLog_insert).call(this, txn, childId, signedMessage.signature, signedMessage.message);
    }
    return result;
};
