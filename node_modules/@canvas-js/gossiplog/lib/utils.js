var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DelayableController_interval, _DelayableController_controller, _DelayableController_timer;
import { anySignal } from "any-signal";
import * as cbor from "@ipld/dag-cbor";
import { lessThan } from "@canvas-js/okra";
export class SyncDeadlockError extends Error {
}
export class SyncTimeoutError extends Error {
}
export class SyncResourceError extends Error {
}
export const cborNull = cbor.encode(null);
// eslint-disable-next-line no-useless-escape
export const topicPattern = /^[a-zA-Z0-9\.\-]+$/;
/** Logarithmic clock decay */
export function* getAncestorClocks(clock) {
    let i = 0;
    while (true) {
        const ancestor = clock - (1 << i++);
        if (ancestor > 0) {
            yield ancestor;
        }
        else {
            break;
        }
    }
}
export function sortPair(a, b) {
    if (lessThan(a.multihash.digest, b.multihash.digest)) {
        return [a, b];
    }
    else {
        return [b, a];
    }
}
export function assert(condition, message) {
    if (!condition) {
        throw new Error(message ?? "assertion failed");
    }
}
export function signalInvalidType(type) {
    console.error(type);
    throw new TypeError("internal error: invalid type");
}
export async function collect(iter, map) {
    const values = [];
    for await (const value of iter) {
        if (map === undefined) {
            values.push(value);
        }
        else {
            values.push(map(value));
        }
    }
    return values;
}
export async function wait(interval, options) {
    if (options.signal.aborted) {
        return;
    }
    const signal = anySignal([AbortSignal.timeout(interval), options.signal]);
    await new Promise((resolve) => {
        signal.addEventListener("abort", () => resolve());
    }).finally(() => signal.clear());
}
export class DelayableController {
    constructor(interval) {
        _DelayableController_interval.set(this, void 0);
        _DelayableController_controller.set(this, void 0);
        _DelayableController_timer.set(this, void 0);
        __classPrivateFieldSet(this, _DelayableController_interval, interval, "f");
        __classPrivateFieldSet(this, _DelayableController_controller, new AbortController(), "f");
        this.signal = __classPrivateFieldGet(this, _DelayableController_controller, "f").signal;
        __classPrivateFieldSet(this, _DelayableController_timer, setTimeout(() => {
            __classPrivateFieldGet(this, _DelayableController_controller, "f").abort();
        }, __classPrivateFieldGet(this, _DelayableController_interval, "f")), "f");
    }
    delay() {
        clearTimeout(__classPrivateFieldGet(this, _DelayableController_timer, "f"));
        __classPrivateFieldSet(this, _DelayableController_timer, setTimeout(() => {
            __classPrivateFieldGet(this, _DelayableController_controller, "f").abort();
        }, __classPrivateFieldGet(this, _DelayableController_interval, "f")), "f");
    }
}
_DelayableController_interval = new WeakMap(), _DelayableController_controller = new WeakMap(), _DelayableController_timer = new WeakMap();
// add elements with CacheMap.add(key, value) and they'll
// get shifted out in the order they were added.
export class CacheMap extends Map {
    constructor(capacity, entries) {
        super();
        this.capacity = capacity;
        for (const [key, value] of entries ?? []) {
            this.set(key, value);
        }
    }
    set(key, value) {
        super.set(key, value);
        for (const key of this.keys()) {
            if (this.size > this.capacity) {
                this.delete(key);
            }
            else {
                break;
            }
        }
        return this;
    }
}
export function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}
