/// <reference path="../types/ipld-schema.d.ts" />
import type { Source, Target, Node, Bound, KeyValueStore } from "@canvas-js/okra";
import { TypedEventEmitter } from "@libp2p/interface";
import { Logger } from "@libp2p/logger";
import { Schema } from "@ipld/schema/schema-schema";
import type { Signature, Signer, Message, Awaitable } from "@canvas-js/interfaces";
import { Mempool } from "./Mempool.js";
import { DelayableController } from "./utils.js";
export interface ReadOnlyTransaction {
    messages: Omit<KeyValueStore, "set" | "delete"> & Source;
    heads: Omit<KeyValueStore, "set" | "delete">;
    ancestors?: Omit<KeyValueStore, "set" | "delete">;
}
export interface ReadWriteTransaction {
    messages: KeyValueStore & Target;
    heads: KeyValueStore;
    ancestors?: KeyValueStore;
}
export type GossipLogConsumer<Payload = unknown, Result = void> = (id: string, signature: Signature, message: Message<Payload>) => Awaitable<Result>;
export interface GossipLogInit<Payload = unknown, Result = void> {
    topic: string;
    apply: GossipLogConsumer<Payload, Result>;
    validate: ((payload: unknown) => payload is Payload) | {
        schema: string | Schema;
        name: string;
    };
    signer?: Signer<Message<Payload>>;
    indexAncestors?: boolean;
}
export type GossipLogEvents<Payload = unknown, Result = void> = {
    message: CustomEvent<{
        id: string;
        signature: Signature;
        message: Message<Payload>;
        result: Result;
    }>;
    commit: CustomEvent<{
        root: Node;
    }>;
    sync: CustomEvent<{
        peer?: string;
        duration: number;
        messageCount: number;
    }>;
    error: CustomEvent<{
        error: Error;
    }>;
};
export declare abstract class AbstractGossipLog<Payload = unknown, Result = unknown> extends TypedEventEmitter<GossipLogEvents<Payload, Result>> {
    #private;
    abstract close(): Promise<void>;
    protected abstract entries(lowerBound?: Bound<Uint8Array> | null, upperBound?: Bound<Uint8Array> | null, options?: {
        reverse?: boolean;
    }): AsyncIterable<[key: Uint8Array, value: Uint8Array]>;
    protected abstract read<T>(callback: (txn: ReadOnlyTransaction) => Awaitable<T>, options?: {
        targetId?: string;
    }): Promise<T>;
    protected abstract write<T>(callback: (txn: ReadWriteTransaction) => Awaitable<T>, options?: {
        sourceId?: string;
    }): Promise<T>;
    readonly topic: string;
    readonly indexAncestors: boolean;
    readonly signer: Signer<Message<Payload>>;
    open: boolean;
    protected readonly log: Logger;
    protected readonly mempool: Mempool<{
        signature: Signature;
        message: Message<Payload>;
    }>;
    protected constructor(init: GossipLogInit<Payload, Result>);
    replay(): Promise<void>;
    iterate(lowerBound?: {
        id: string;
        inclusive: boolean;
    } | null, upperBound?: {
        id: string;
        inclusive: boolean;
    } | null, options?: {
        reverse?: boolean;
    }): AsyncIterable<[id: string, signature: Signature, message: Message<Payload>]>;
    encode(signature: Signature, message: Message<Payload>): [key: Uint8Array, value: Uint8Array];
    decode(value: Uint8Array): [id: string, signature: Signature, message: Message<Payload>];
    getClock(): Promise<[clock: number, heads: string[]]>;
    has(id: string): Promise<boolean>;
    get(id: string): Promise<[signature: Signature, message: Message<Payload>] | [null, null]>;
    private getHeads;
    /**
     * Sign and append a new *unsigned* message to the end of the log.
     * The currently unmerged heads of the local log are used as parents.
     */
    append(payload: Payload, options?: {
        signer?: Signer<Message<Payload>>;
    }): Promise<{
        id: string;
        signature: Signature;
        message: Message<Payload>;
        result: Result;
    }>;
    /**
     * Insert an existing signed message into the log (ie received via PubSub).
     * If any of the parents are not present, insert the message into the mempool instead.
     */
    insert(signature: Signature, message: Message<Payload>): Promise<{
        id: string;
    }>;
    getAncestors(id: string, atOrBefore: number): Promise<string[]>;
    isAncestor(id: string, ancestor: string): Promise<boolean>;
    static isAncestor(txn: ReadOnlyTransaction, id: string, ancestor: string, visited?: Set<string>): Promise<boolean>;
    /**
     * Sync with a remote source, applying and inserting all missing messages into the local log
     */
    sync(source: Source, options?: {
        sourceId?: string;
        timeoutController?: DelayableController;
    }): Promise<{
        root: Node;
        messageCount: number;
    }>;
    /**
     * Serve a read-only snapshot of the merkle tree
     */
    serve(callback: (source: Source) => Promise<void>, options?: {
        targetId?: string;
    }): Promise<void>;
}
