var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _GossipLogService_started, _GossipLogService_messageLogs, _GossipLogService_syncServices, _GossipLogService_pubsub;
import { TypedEventEmitter } from "@libp2p/interface";
import { GossipSub } from "@chainsafe/libp2p-gossipsub";
import { logger } from "@libp2p/logger";
import { decodeId } from "./schema.js";
import { SyncService } from "./sync/service.js";
import { assert } from "./utils.js";
export class GossipLogService extends TypedEventEmitter {
    static extractGossipSub(components) {
        const { pubsub } = components;
        assert(pubsub !== undefined, "pubsub service not found");
        assert(pubsub instanceof GossipSub);
        return pubsub;
    }
    constructor(components, init) {
        super();
        this.components = components;
        this.log = logger(`canvas:gossiplog`);
        _GossipLogService_started.set(this, false);
        _GossipLogService_messageLogs.set(this, new Map());
        _GossipLogService_syncServices.set(this, new Map());
        _GossipLogService_pubsub.set(this, void 0);
        this.forwardEvent = (event) => this.safeDispatchEvent(event.type, event);
        this.handleMessage = async ({ detail: msg }) => {
            if (!msg.topic.startsWith(GossipLogService.topicPrefix)) {
                return;
            }
            const topic = msg.topic.slice(GossipLogService.topicPrefix.length);
            const messageLog = __classPrivateFieldGet(this, _GossipLogService_messageLogs, "f").get(topic);
            if (messageLog === undefined) {
                return;
            }
            try {
                const [id, signature, message] = messageLog.decode(msg.data);
                this.log("received message %s via gossipsub on %s", id, topic);
                await messageLog.insert(signature, message);
            }
            catch (err) {
                this.log("received invalid message via gossipsub on %s", topic);
                this.log(err);
            }
        };
        this.sync = init.sync ?? true;
        __classPrivateFieldSet(this, _GossipLogService_pubsub, GossipLogService.extractGossipSub(components), "f");
    }
    isStarted() {
        return __classPrivateFieldGet(this, _GossipLogService_started, "f");
    }
    async start() {
        this.log("start");
        __classPrivateFieldGet(this, _GossipLogService_pubsub, "f").addEventListener("message", this.handleMessage);
        __classPrivateFieldSet(this, _GossipLogService_started, true, "f");
    }
    async afterStart() {
        this.log("afterStart");
        for (const syncService of __classPrivateFieldGet(this, _GossipLogService_syncServices, "f").values()) {
            await syncService.start();
        }
        for (const topic of __classPrivateFieldGet(this, _GossipLogService_messageLogs, "f").keys()) {
            __classPrivateFieldGet(this, _GossipLogService_pubsub, "f").subscribe(GossipLogService.topicPrefix + topic);
        }
    }
    async beforeStop() {
        this.log("beforeStop");
        await Promise.all(Array.from(__classPrivateFieldGet(this, _GossipLogService_syncServices, "f").values()).map((syncService) => syncService.stop()));
        __classPrivateFieldGet(this, _GossipLogService_syncServices, "f").clear();
    }
    async stop() {
        this.log("stop");
        __classPrivateFieldGet(this, _GossipLogService_pubsub, "f").removeEventListener("message", this.handleMessage);
        __classPrivateFieldGet(this, _GossipLogService_messageLogs, "f").clear();
        __classPrivateFieldGet(this, _GossipLogService_syncServices, "f").clear();
        __classPrivateFieldSet(this, _GossipLogService_started, false, "f");
    }
    async subscribe(messageLog, options = {}) {
        this.log("subscribing to %s", messageLog.topic);
        __classPrivateFieldGet(this, _GossipLogService_messageLogs, "f").set(messageLog.topic, messageLog);
        messageLog.addEventListener("sync", this.forwardEvent);
        messageLog.addEventListener("commit", this.forwardEvent);
        messageLog.addEventListener("message", this.forwardEvent);
        if (this.sync) {
            const syncService = new SyncService(this.components, messageLog, options);
            __classPrivateFieldGet(this, _GossipLogService_syncServices, "f").set(messageLog.topic, syncService);
            if (__classPrivateFieldGet(this, _GossipLogService_started, "f")) {
                await syncService.start();
            }
        }
        if (__classPrivateFieldGet(this, _GossipLogService_started, "f")) {
            __classPrivateFieldGet(this, _GossipLogService_pubsub, "f").subscribe(GossipLogService.topicPrefix + messageLog.topic);
        }
    }
    async unsubscribe(topic) {
        this.log("unsubscribing from %s", topic);
        if (__classPrivateFieldGet(this, _GossipLogService_started, "f")) {
            __classPrivateFieldGet(this, _GossipLogService_pubsub, "f").unsubscribe(GossipLogService.topicPrefix + topic);
        }
        const syncService = __classPrivateFieldGet(this, _GossipLogService_syncServices, "f").get(topic);
        if (syncService !== undefined) {
            await syncService.stop();
            __classPrivateFieldGet(this, _GossipLogService_syncServices, "f").delete(topic);
        }
        const messageLog = __classPrivateFieldGet(this, _GossipLogService_messageLogs, "f").get(topic);
        if (messageLog !== undefined) {
            messageLog.removeEventListener("sync", this.forwardEvent);
            messageLog.removeEventListener("commit", this.forwardEvent);
            messageLog.removeEventListener("message", this.forwardEvent);
            __classPrivateFieldGet(this, _GossipLogService_messageLogs, "f").delete(topic);
        }
    }
    async append(topic, payload, options = {}) {
        const messageLog = __classPrivateFieldGet(this, _GossipLogService_messageLogs, "f").get(topic);
        assert(messageLog !== undefined, "no subscription for topic");
        const { id, signature, message, result } = await messageLog.append(payload, options);
        if (__classPrivateFieldGet(this, _GossipLogService_started, "f")) {
            const [key, value] = messageLog.encode(signature, message);
            assert(decodeId(key) === id);
            const recipients = __classPrivateFieldGet(this, _GossipLogService_pubsub, "f").publish(GossipLogService.topicPrefix + topic, value).then(({ recipients }) => {
                this.log("published message %s to %d recipients %O", id, recipients.length, recipients);
                return recipients;
            }, (err) => {
                this.log.error("failed to publish event: %O", err);
                return [];
            });
            return { id, result, recipients };
        }
        else {
            return { id, result, recipients: Promise.resolve([]) };
        }
    }
    async insert(signature, message) {
        const messageLog = __classPrivateFieldGet(this, _GossipLogService_messageLogs, "f").get(message.topic);
        assert(messageLog !== undefined, "topic not found");
        const { id } = await messageLog.insert(signature, message);
        if (__classPrivateFieldGet(this, _GossipLogService_started, "f")) {
            const [key, value] = messageLog.encode(signature, message);
            const id = decodeId(key);
            const recipients = __classPrivateFieldGet(this, _GossipLogService_pubsub, "f").publish(GossipLogService.topicPrefix + message.topic, value).then(({ recipients }) => {
                this.log("published message %s to %d recipients %O", id, recipients.length, recipients);
                return recipients;
            }, (err) => {
                this.log.error("failed to publish event: %O", err);
                return [];
            });
            return { id, recipients };
        }
        else {
            return { id, recipients: Promise.resolve([]) };
        }
    }
    getTopics() {
        return [...__classPrivateFieldGet(this, _GossipLogService_messageLogs, "f").keys()];
    }
}
_GossipLogService_started = new WeakMap(), _GossipLogService_messageLogs = new WeakMap(), _GossipLogService_syncServices = new WeakMap(), _GossipLogService_pubsub = new WeakMap();
GossipLogService.topicPrefix = "canvas/";
export const gossiplog = (init) => (components) => new GossipLogService(components, init);
