/* eslint-disable import/export */
/* eslint-disable complexity */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { encodeMessage, decodeMessage, message } from 'protons-runtime';
export var Node;
(function (Node) {
    let _codec;
    Node.codec = () => {
        if (_codec == null) {
            _codec = message((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.level != null && obj.level !== 0)) {
                    w.uint32(8);
                    w.uint32(obj.level);
                }
                if ((obj.key != null && obj.key.byteLength > 0)) {
                    w.uint32(18);
                    w.bytes(obj.key);
                }
                if ((obj.hash != null && obj.hash.byteLength > 0)) {
                    w.uint32(26);
                    w.bytes(obj.hash);
                }
                if (obj.value != null) {
                    w.uint32(34);
                    w.bytes(obj.value);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length) => {
                const obj = {
                    level: 0,
                    key: new Uint8Array(0),
                    hash: new Uint8Array(0)
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.level = reader.uint32();
                            break;
                        }
                        case 2: {
                            obj.key = reader.bytes();
                            break;
                        }
                        case 3: {
                            obj.hash = reader.bytes();
                            break;
                        }
                        case 4: {
                            obj.value = reader.bytes();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    Node.encode = (obj) => {
        return encodeMessage(obj, Node.codec());
    };
    Node.decode = (buf) => {
        return decodeMessage(buf, Node.codec());
    };
})(Node || (Node = {}));
export var Request;
(function (Request) {
    let GetRootRequest;
    (function (GetRootRequest) {
        let _codec;
        GetRootRequest.codec = () => {
            if (_codec == null) {
                _codec = message((obj, w, opts = {}) => {
                    if (opts.lengthDelimited !== false) {
                        w.fork();
                    }
                    if (opts.lengthDelimited !== false) {
                        w.ldelim();
                    }
                }, (reader, length) => {
                    const obj = {};
                    const end = length == null ? reader.len : reader.pos + length;
                    while (reader.pos < end) {
                        const tag = reader.uint32();
                        switch (tag >>> 3) {
                            default: {
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                    }
                    return obj;
                });
            }
            return _codec;
        };
        GetRootRequest.encode = (obj) => {
            return encodeMessage(obj, GetRootRequest.codec());
        };
        GetRootRequest.decode = (buf) => {
            return decodeMessage(buf, GetRootRequest.codec());
        };
    })(GetRootRequest = Request.GetRootRequest || (Request.GetRootRequest = {}));
    let GetNodeRequest;
    (function (GetNodeRequest) {
        let _codec;
        GetNodeRequest.codec = () => {
            if (_codec == null) {
                _codec = message((obj, w, opts = {}) => {
                    if (opts.lengthDelimited !== false) {
                        w.fork();
                    }
                    if ((obj.level != null && obj.level !== 0)) {
                        w.uint32(8);
                        w.uint32(obj.level);
                    }
                    if ((obj.key != null && obj.key.byteLength > 0)) {
                        w.uint32(18);
                        w.bytes(obj.key);
                    }
                    if (opts.lengthDelimited !== false) {
                        w.ldelim();
                    }
                }, (reader, length) => {
                    const obj = {
                        level: 0,
                        key: new Uint8Array(0)
                    };
                    const end = length == null ? reader.len : reader.pos + length;
                    while (reader.pos < end) {
                        const tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1: {
                                obj.level = reader.uint32();
                                break;
                            }
                            case 2: {
                                obj.key = reader.bytes();
                                break;
                            }
                            default: {
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                    }
                    return obj;
                });
            }
            return _codec;
        };
        GetNodeRequest.encode = (obj) => {
            return encodeMessage(obj, GetNodeRequest.codec());
        };
        GetNodeRequest.decode = (buf) => {
            return decodeMessage(buf, GetNodeRequest.codec());
        };
    })(GetNodeRequest = Request.GetNodeRequest || (Request.GetNodeRequest = {}));
    let GetChildrenRequest;
    (function (GetChildrenRequest) {
        let _codec;
        GetChildrenRequest.codec = () => {
            if (_codec == null) {
                _codec = message((obj, w, opts = {}) => {
                    if (opts.lengthDelimited !== false) {
                        w.fork();
                    }
                    if ((obj.level != null && obj.level !== 0)) {
                        w.uint32(8);
                        w.uint32(obj.level);
                    }
                    if ((obj.key != null && obj.key.byteLength > 0)) {
                        w.uint32(18);
                        w.bytes(obj.key);
                    }
                    if (opts.lengthDelimited !== false) {
                        w.ldelim();
                    }
                }, (reader, length) => {
                    const obj = {
                        level: 0,
                        key: new Uint8Array(0)
                    };
                    const end = length == null ? reader.len : reader.pos + length;
                    while (reader.pos < end) {
                        const tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1: {
                                obj.level = reader.uint32();
                                break;
                            }
                            case 2: {
                                obj.key = reader.bytes();
                                break;
                            }
                            default: {
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                    }
                    return obj;
                });
            }
            return _codec;
        };
        GetChildrenRequest.encode = (obj) => {
            return encodeMessage(obj, GetChildrenRequest.codec());
        };
        GetChildrenRequest.decode = (buf) => {
            return decodeMessage(buf, GetChildrenRequest.codec());
        };
    })(GetChildrenRequest = Request.GetChildrenRequest || (Request.GetChildrenRequest = {}));
    let _codec;
    Request.codec = () => {
        if (_codec == null) {
            _codec = message((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.getRoot != null) {
                    w.uint32(10);
                    Request.GetRootRequest.codec().encode(obj.getRoot, w);
                }
                if (obj.getNode != null) {
                    w.uint32(18);
                    Request.GetNodeRequest.codec().encode(obj.getNode, w);
                }
                if (obj.getChildren != null) {
                    w.uint32(26);
                    Request.GetChildrenRequest.codec().encode(obj.getChildren, w);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length) => {
                const obj = {};
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.getRoot = Request.GetRootRequest.codec().decode(reader, reader.uint32());
                            break;
                        }
                        case 2: {
                            obj.getNode = Request.GetNodeRequest.codec().decode(reader, reader.uint32());
                            break;
                        }
                        case 3: {
                            obj.getChildren = Request.GetChildrenRequest.codec().decode(reader, reader.uint32());
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    Request.encode = (obj) => {
        return encodeMessage(obj, Request.codec());
    };
    Request.decode = (buf) => {
        return decodeMessage(buf, Request.codec());
    };
})(Request || (Request = {}));
export var Response;
(function (Response) {
    let GetRootResponse;
    (function (GetRootResponse) {
        let _codec;
        GetRootResponse.codec = () => {
            if (_codec == null) {
                _codec = message((obj, w, opts = {}) => {
                    if (opts.lengthDelimited !== false) {
                        w.fork();
                    }
                    if (obj.root != null) {
                        w.uint32(10);
                        Node.codec().encode(obj.root, w);
                    }
                    if (opts.lengthDelimited !== false) {
                        w.ldelim();
                    }
                }, (reader, length) => {
                    const obj = {};
                    const end = length == null ? reader.len : reader.pos + length;
                    while (reader.pos < end) {
                        const tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1: {
                                obj.root = Node.codec().decode(reader, reader.uint32());
                                break;
                            }
                            default: {
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                    }
                    return obj;
                });
            }
            return _codec;
        };
        GetRootResponse.encode = (obj) => {
            return encodeMessage(obj, GetRootResponse.codec());
        };
        GetRootResponse.decode = (buf) => {
            return decodeMessage(buf, GetRootResponse.codec());
        };
    })(GetRootResponse = Response.GetRootResponse || (Response.GetRootResponse = {}));
    let GetNodeResponse;
    (function (GetNodeResponse) {
        let _codec;
        GetNodeResponse.codec = () => {
            if (_codec == null) {
                _codec = message((obj, w, opts = {}) => {
                    if (opts.lengthDelimited !== false) {
                        w.fork();
                    }
                    if (obj.node != null) {
                        w.uint32(10);
                        Node.codec().encode(obj.node, w);
                    }
                    if (opts.lengthDelimited !== false) {
                        w.ldelim();
                    }
                }, (reader, length) => {
                    const obj = {};
                    const end = length == null ? reader.len : reader.pos + length;
                    while (reader.pos < end) {
                        const tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1: {
                                obj.node = Node.codec().decode(reader, reader.uint32());
                                break;
                            }
                            default: {
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                    }
                    return obj;
                });
            }
            return _codec;
        };
        GetNodeResponse.encode = (obj) => {
            return encodeMessage(obj, GetNodeResponse.codec());
        };
        GetNodeResponse.decode = (buf) => {
            return decodeMessage(buf, GetNodeResponse.codec());
        };
    })(GetNodeResponse = Response.GetNodeResponse || (Response.GetNodeResponse = {}));
    let GetChildrenResponse;
    (function (GetChildrenResponse) {
        let _codec;
        GetChildrenResponse.codec = () => {
            if (_codec == null) {
                _codec = message((obj, w, opts = {}) => {
                    if (opts.lengthDelimited !== false) {
                        w.fork();
                    }
                    if (obj.children != null) {
                        for (const value of obj.children) {
                            w.uint32(10);
                            Node.codec().encode(value, w);
                        }
                    }
                    if (opts.lengthDelimited !== false) {
                        w.ldelim();
                    }
                }, (reader, length) => {
                    const obj = {
                        children: []
                    };
                    const end = length == null ? reader.len : reader.pos + length;
                    while (reader.pos < end) {
                        const tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1: {
                                obj.children.push(Node.codec().decode(reader, reader.uint32()));
                                break;
                            }
                            default: {
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                    }
                    return obj;
                });
            }
            return _codec;
        };
        GetChildrenResponse.encode = (obj) => {
            return encodeMessage(obj, GetChildrenResponse.codec());
        };
        GetChildrenResponse.decode = (buf) => {
            return decodeMessage(buf, GetChildrenResponse.codec());
        };
    })(GetChildrenResponse = Response.GetChildrenResponse || (Response.GetChildrenResponse = {}));
    let _codec;
    Response.codec = () => {
        if (_codec == null) {
            _codec = message((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.getRoot != null) {
                    w.uint32(10);
                    Response.GetRootResponse.codec().encode(obj.getRoot, w);
                }
                if (obj.getNode != null) {
                    w.uint32(18);
                    Response.GetNodeResponse.codec().encode(obj.getNode, w);
                }
                if (obj.getChildren != null) {
                    w.uint32(26);
                    Response.GetChildrenResponse.codec().encode(obj.getChildren, w);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length) => {
                const obj = {};
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.getRoot = Response.GetRootResponse.codec().decode(reader, reader.uint32());
                            break;
                        }
                        case 2: {
                            obj.getNode = Response.GetNodeResponse.codec().decode(reader, reader.uint32());
                            break;
                        }
                        case 3: {
                            obj.getChildren = Response.GetChildrenResponse.codec().decode(reader, reader.uint32());
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    Response.encode = (obj) => {
        return encodeMessage(obj, Response.codec());
    };
    Response.decode = (buf) => {
        return decodeMessage(buf, Response.codec());
    };
})(Response || (Response = {}));
