export declare class Mempool<T> {
    readonly log: import("@libp2p/logger").Logger;
    readonly values: Map<string, T>;
    /** `missingParents` stores the missing parents "blocking" each message in `messages` */
    readonly missingParents: Map<string, Set<string>>;
    /**
     * When we observe a value, we need to look up any mempool entries which
     * depended on that value that are now eligible for application themselves.
     * `waitingChildren` is a map from the parent ids of all mempool entries
     * (ie the union of all the sets in `missingParents`) to the set of children
     * (ie keys in `missingParents`) that depend on them.
     */
    readonly waitingChildren: Map<string, Set<string>>;
    constructor();
    add(id: string, value: T, missingParents: Set<string>): void;
    /**
     * This is called for every message added to the log (both appends and inserts).
     * It removes all references to the inserted message and returns a set of "unblocked" messages.
     */
    observe(id: string): Iterable<[id: string, value: T]>;
}
