import PQueue from "p-queue";
import pDefer from "p-defer";
import { MemoryTree, MemoryStore } from "@canvas-js/okra-memory";
import { AbstractGossipLog } from "../AbstractGossipLog.js";
import { assert, SyncDeadlockError } from "../utils.js";
export class GossipLog extends AbstractGossipLog {
    static async open(init) {
        const messages = await MemoryTree.open();
        const heads = new MemoryStore();
        const ancestors = new MemoryStore();
        return new GossipLog(messages, heads, ancestors, init);
    }
    constructor(messages, heads, ancestors, init) {
        super(init);
        this.messages = messages;
        this.heads = heads;
        this.ancestors = ancestors;
        this.queue = new PQueue({ concurrency: 1 });
        this.incomingSyncPeers = new Set();
        this.outgoingSyncPeers = new Set();
    }
    async close() {
        this.log("closing");
        this.queue.clear();
        await this.queue.onIdle();
        await this.messages.store.close();
        await this.heads.close();
    }
    async *entries(lowerBound = null, upperBound = null, options = {}) {
        const deferred = pDefer();
        this.queue.add(() => {
            return deferred.promise;
        });
        try {
            for await (const node of this.messages.nodes(0, lowerBound ?? { key: null, inclusive: false }, upperBound, options)) {
                assert(node.key !== null, "expected node.key !== null");
                assert(node.value !== undefined, "expected node.value !== undefined");
                yield [node.key, node.value];
            }
        }
        finally {
            deferred.resolve();
        }
    }
    async read(callback, options = {}) {
        const targetId = options.targetId ?? null;
        if (targetId !== null) {
            if (this.outgoingSyncPeers.has(targetId)) {
                throw new SyncDeadlockError(`deadlock with peer ${targetId}`);
            }
        }
        const result = await this.queue.add(async () => {
            if (targetId !== null) {
                this.incomingSyncPeers.add(targetId);
            }
            try {
                return await callback({ messages: this.messages, heads: this.heads, ancestors: this.ancestors });
            }
            catch (err) {
                this.log.error("error in transaction: %O", err);
            }
            finally {
                if (targetId !== null) {
                    this.incomingSyncPeers.delete(targetId);
                }
            }
        });
        return result;
    }
    async write(callback, options = {}) {
        const sourceId = options.sourceId ?? null;
        if (sourceId !== null) {
            if (this.incomingSyncPeers.has(sourceId)) {
                throw new SyncDeadlockError(`deadlock with peer ${sourceId}`);
            }
        }
        const result = await this.queue.add(async () => {
            if (sourceId !== null) {
                this.outgoingSyncPeers.add(sourceId);
            }
            try {
                return await callback({ messages: this.messages, heads: this.heads, ancestors: this.ancestors });
            }
            catch (err) {
                this.log.error("error in transaction: %O", err);
                throw err;
            }
            finally {
                if (sourceId !== null) {
                    this.outgoingSyncPeers.delete(sourceId);
                }
            }
        });
        return result;
    }
}
