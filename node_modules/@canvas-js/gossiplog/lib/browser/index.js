import pDefer from "p-defer";
import { bytesToHex, randomBytes } from "@noble/hashes/utils";
import { IDBStore, IDBTree } from "@canvas-js/okra-idb";
import { openDB } from "idb";
import { AbstractGossipLog } from "../AbstractGossipLog.js";
import { assert, SyncDeadlockError, SyncResourceError } from "../utils.js";
export class GossipLog extends AbstractGossipLog {
    static async open(init) {
        const storeNames = ["messages", "heads", "ancestors"];
        const db = await openDB(`canvas/${init.topic}/log`, 2, {
            upgrade: (db, oldVersion, newVersion) => {
                for (const storeName of storeNames) {
                    if (db.objectStoreNames.contains(storeName)) {
                        continue;
                    }
                    else {
                        db.createObjectStore(storeName);
                    }
                }
            },
        });
        const messages = await IDBTree.open(db, "messages");
        const heads = new IDBStore(db, "heads");
        const ancestors = new IDBStore(db, "ancestors");
        return new GossipLog(db, messages, heads, ancestors, init);
    }
    constructor(db, messages, heads, ancestors, init) {
        super(init);
        this.db = db;
        this.messages = messages;
        this.heads = heads;
        this.ancestors = ancestors;
        this.incomingSyncPeers = new Set();
        this.outgoingSyncPeers = new Set();
        this.controller = new AbortController();
        this.lockName = bytesToHex(randomBytes(16));
        db.addEventListener("error", (event) => this.log("db: error", event));
        db.addEventListener("close", (event) => this.log("db: close", event));
        db.addEventListener("versionchange", (event) => {
            this.log("db: versionchange", event);
            if (event.oldVersion === null && event.newVersion !== null) {
                // create
                return;
            }
            else if (event.oldVersion !== null && event.newVersion !== null) {
                // update
                return;
            }
            else if (event.oldVersion !== null && event.newVersion === null) {
                // delete
                db.close();
                return;
            }
        });
    }
    async close() {
        this.log("closing");
        this.open = false;
        this.controller.abort();
        this.db.close();
    }
    async *entries(lowerBound = null, upperBound = null, options = {}) {
        this.log("requesting shared lock");
        const deferred = pDefer();
        navigator.locks.request(this.lockName, { mode: "shared", signal: this.controller.signal }, (lock) => {
            if (lock === null) {
                this.log.error("failed to acquire shared lock");
                throw new SyncResourceError(`failed to acquire shared lock ${this.lockName}`);
            }
            this.log("acquired shared lock");
            return deferred.promise;
        });
        if (this.messages.store.txn === null) {
            this.messages.store.txn = this.db.transaction(this.messages.store.storeName, "readonly");
        }
        try {
            for await (const node of this.messages.nodes(0, lowerBound ?? { key: null, inclusive: false }, upperBound, options)) {
                assert(node.key !== null, "expected node.key !== null");
                assert(node.value !== undefined, "expected node.value !== undefined");
                yield [node.key, node.value];
            }
        }
        finally {
            this.messages.store.txn = null;
            this.log("releasing shared lock");
            deferred.resolve();
        }
    }
    async read(callback, options = {}) {
        const targetId = options.targetId ?? null;
        if (targetId !== null) {
            if (this.outgoingSyncPeers.has(targetId)) {
                throw new SyncDeadlockError(`deadlock with peer ${targetId}`);
            }
        }
        let result = undefined;
        this.log("requesting shared lock");
        await navigator.locks.request(this.lockName, { mode: "shared", signal: this.controller.signal }, async (lock) => {
            if (lock === null) {
                this.log.error("failed to acquire shared lock");
                throw new SyncResourceError(`failed to acquire shared lock ${this.lockName}`);
            }
            this.log("acquired shared lock");
            if (targetId !== null) {
                this.incomingSyncPeers.add(targetId);
            }
            const heads = {
                get: (key) => this.heads.read(() => this.heads.get(key)),
                entries: (lowerBound = null, upperBound = null, options = {}) => {
                    this.heads.txn = this.db.transaction(this.heads.storeName, "readonly");
                    return this.heads.entries(lowerBound, upperBound, options);
                },
            };
            const ancestors = {
                get: (key) => this.ancestors.read(() => this.ancestors.get(key)),
                entries: (lowerBound = null, upperBound = null, options = {}) => {
                    this.ancestors.txn = this.db.transaction(this.ancestors.storeName, "readonly");
                    return this.ancestors.entries(lowerBound, upperBound, options);
                },
            };
            try {
                result = await callback({ messages: this.messages, heads, ancestors });
            }
            catch (err) {
                if (err instanceof Error && err.name === "TransactionInactiveError") {
                    this.log.error("incoming merkle sync attempted, but transaction was invalid"); // TODO: better txn handling
                }
                else if (err instanceof Error && err.name === "Error" && err.message === "TIMEOUT") {
                    this.log.error("incoming merkle sync reached timeout"); // TODO: this should be happening less
                }
                else {
                    this.log.error("error in read-only transaction: %O", err);
                }
            }
            finally {
                this.log("releasing shared lock");
                if (targetId !== null) {
                    this.incomingSyncPeers.delete(targetId);
                }
            }
        });
        return result;
    }
    async write(callback, options = {}) {
        const sourceId = options.sourceId ?? null;
        if (sourceId !== null) {
            if (this.incomingSyncPeers.has(sourceId)) {
                throw new SyncDeadlockError(`deadlock with peer ${sourceId}`);
            }
        }
        if (!this.open) {
            throw new Error("gossiplog closed");
        }
        let result = undefined;
        let error = null;
        this.log("requesting exclusive lock");
        await navigator.locks.request(this.lockName, { mode: "exclusive", signal: this.controller.signal }, async (lock) => {
            if (lock === null) {
                this.log.error("failed to exclusive lock");
                throw new SyncResourceError(`failed to acquire exclusive lock ${this.lockName}`);
            }
            this.log("acquired exclusive lock");
            if (sourceId !== null) {
                this.outgoingSyncPeers.add(sourceId);
            }
            const heads = {
                get: (key) => this.heads.read(() => this.heads.get(key)),
                set: (key, value) => this.heads.write(() => this.heads.set(key, value)),
                delete: (key) => this.heads.write(() => this.heads.delete(key)),
                entries: (lowerBound = null, upperBound = null, options = {}) => {
                    this.heads.txn = this.db.transaction(this.heads.storeName, "readonly");
                    return this.heads.entries(lowerBound, upperBound, options);
                },
            };
            const ancestors = {
                get: (key) => this.ancestors.read(() => this.ancestors.get(key)),
                set: (key, value) => this.ancestors.write(() => this.ancestors.set(key, value)),
                delete: (key) => this.ancestors.write(() => this.ancestors.delete(key)),
                entries: (lowerBound = null, upperBound = null, options = {}) => {
                    this.ancestors.txn = this.db.transaction(this.ancestors.storeName, "readonly");
                    return this.ancestors.entries(lowerBound, upperBound, options);
                },
            };
            try {
                result = await callback({ messages: this.messages, heads, ancestors });
            }
            catch (err) {
                this.log.error("error in read-write transaction: %O", err);
                error = err;
                throw err;
            }
            finally {
                this.log("releasing exclusive lock");
                if (sourceId !== null) {
                    this.outgoingSyncPeers.delete(sourceId);
                }
            }
        });
        // this is just a workaround for fake-indexeddb which doesn't throw exceptions right
        if (error !== null) {
            throw error;
        }
        return result;
    }
}
