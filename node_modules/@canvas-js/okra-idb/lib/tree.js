import { Tree, assert } from "@canvas-js/okra";
import { IDBStore } from "./store.js";
export class IDBTree extends Tree {
    store;
    static async open(db, storeName, options = {}) {
        const store = new IDBStore(db, storeName);
        const tree = new IDBTree(store, options);
        await store.write(() => tree.initialize());
        return tree;
    }
    constructor(store, options) {
        super(store, options);
        this.store = store;
    }
    async get(key) {
        return this.store.read(() => super.get(key));
    }
    async set(key, value) {
        if (this.store.txn === null) {
            await this.store.write(() => super.set(key, value));
        }
        else {
            await super.set(key, value);
        }
    }
    async delete(key) {
        if (this.store.txn === null) {
            await this.store.write(() => super.delete(key));
        }
        else {
            await super.delete(key);
        }
    }
    async getRoot() {
        if (this.store.txn === null) {
            return this.store.read(() => super.getRoot());
        }
        else {
            return super.getRoot();
        }
    }
    getNode(level, key) {
        if (this.store.txn === null) {
            return this.store.read(() => super.getNode(level, key));
        }
        else {
            return super.getNode(level, key);
        }
    }
    getChildren(level, key) {
        if (this.store.txn === null) {
            return this.store.read(() => super.getChildren(level, key));
        }
        else {
            return super.getChildren(level, key);
        }
    }
    async *nodes(level, lowerBound = null, upperBound = null, { reverse = false } = {}) {
        if (this.store.txn === null) {
            // TODO: fix this
            throw new Error("can only call nodes() from within a managed transaction");
        }
        else {
            yield* super.nodes(level, lowerBound, upperBound, { reverse });
        }
    }
    async *entries(lowerBound = null, upperBound = null, { reverse = false } = {}) {
        if (this.store.txn === null) {
            // TODO: fix this
            throw new Error("can only call entries() from within a managed transaction");
        }
        else {
            for await (const leaf of this.nodes(0, lowerBound ?? { key: null, inclusive: false }, upperBound, { reverse })) {
                assert(leaf.key !== null && leaf.value !== undefined, "invalid leaf entry");
                yield [leaf.key, leaf.value];
            }
        }
    }
}
