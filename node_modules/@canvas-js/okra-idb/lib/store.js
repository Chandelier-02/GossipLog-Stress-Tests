import { assert } from "@canvas-js/okra";
import { debug } from "./format.js";
export class IDBStore {
    db;
    storeName;
    log = debug("okra-idb:store");
    txn = null;
    constructor(db, storeName) {
        this.db = db;
        this.storeName = storeName;
    }
    async write(callback) {
        this.txn = this.db.transaction(this.storeName, "readwrite");
        try {
            const result = await callback();
            this.txn.commit();
            return result;
        }
        catch (err) {
            console.error(err);
            this.txn.abort();
        }
        finally {
            this.txn = null;
        }
    }
    async read(callback) {
        this.txn = this.db.transaction(this.storeName, "readonly");
        try {
            return await callback();
        }
        finally {
            this.txn = null;
        }
    }
    async get(key) {
        this.log(`get(%h})`, key);
        assert(this.txn !== null, "Internal error: this.txn !== null");
        const store = this.txn.objectStore(this.storeName);
        const value = await store.get(key);
        if (value === undefined) {
            return null;
        }
        else if (value instanceof Uint8Array) {
            return value;
        }
        else {
            throw new Error("Unexpected value type");
        }
    }
    async set(key, value) {
        this.log(`set(%h, %h)`, key, value);
        assert(this.txn !== null, "Internal error: this.txn !== null");
        const store = this.txn.objectStore(this.storeName);
        if (this.txn.mode === "readonly" || store.put === undefined) {
            throw new Error("Cannot set in a read-only transaction");
        }
        await store.put(value, key);
    }
    async delete(key) {
        assert(this.txn !== null, "Internal error: this.txn !== null");
        const store = this.txn.objectStore(this.storeName);
        if (this.txn.mode === "readonly" || store.delete === undefined) {
            throw new Error("Cannot delete in a read-only transaction");
        }
        await store.delete(key);
    }
    async *entries(lowerBound = null, upperBound = null, { reverse = false } = {}) {
        let query = null;
        if (lowerBound && upperBound) {
            query = IDBKeyRange.bound(lowerBound.key, upperBound.key, !lowerBound.inclusive, !upperBound.inclusive);
        }
        else if (lowerBound) {
            query = IDBKeyRange.lowerBound(lowerBound.key, !lowerBound.inclusive);
        }
        else if (upperBound) {
            query = IDBKeyRange.upperBound(upperBound.key, !upperBound.inclusive);
        }
        assert(this.txn !== null, "Internal error: this.txn !== null");
        const store = this.txn.objectStore(this.storeName);
        let cursor = await store.openCursor(query, reverse ? "prev" : "next");
        while (cursor !== null) {
            let key = null;
            if (cursor.key instanceof Uint8Array) {
                key = cursor.key;
            }
            else if (cursor.key instanceof ArrayBuffer) {
                key = new Uint8Array(cursor.key);
            }
            else {
                throw new Error("Unexpected cursor key type");
            }
            if (cursor.value instanceof Uint8Array) {
                yield [key, cursor.value];
            }
            else {
                throw new Error("Unexpected cursor value type");
            }
            cursor = await cursor.continue();
        }
    }
}
