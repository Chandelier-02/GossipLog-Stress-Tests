(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PPerf = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PPerf=(()=>{var O=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var I=Object.prototype.hasOwnProperty;var k=(s,t)=>{for(var e in t)O(s,e,{get:t[e],enumerable:!0})},M=(s,t,e,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of v(t))!I.call(s,n)&&n!==e&&O(s,n,{get:()=>t[n],enumerable:!(o=A(t,n))||o.enumerable});return s};var R=s=>M(O({},"__esModule",{value:!0}),s);var j={};k(j,{perf:()=>X});function S(){let s={};return s.promise=new Promise((t,e)=>{s.resolve=t,s.reject=e}),s}var g=class{buffer;mask;top;btm;next;constructor(t){if(!(t>0)||t-1&t)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(t),this.mask=t-1,this.top=0,this.btm=0,this.next=null}push(t){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=t,this.top=this.top+1&this.mask,!0)}shift(){let t=this.buffer[this.btm];if(t!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,t}isEmpty(){return this.buffer[this.btm]===void 0}},b=class{size;hwm;head;tail;constructor(t={}){this.hwm=t.splitLimit??16,this.head=new g(this.hwm),this.tail=this.head,this.size=0}calculateSize(t){return t?.byteLength!=null?t.byteLength:1}push(t){if(t?.value!=null&&(this.size+=this.calculateSize(t.value)),!this.head.push(t)){let e=this.head;this.head=e.next=new g(2*this.head.buffer.length),this.head.push(t)}}shift(){let t=this.tail.shift();if(t===void 0&&this.tail.next!=null){let e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return t?.value!=null&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}};var N=class extends Error{type;code;constructor(t,e){super(t??"The operation was aborted"),this.type="aborted",this.code=e??"ABORT_ERR"}};function B(s={}){return z(e=>{let o=e.shift();if(o==null)return{done:!0};if(o.error!=null)throw o.error;return{done:o.done===!0,value:o.value}},s)}function z(s,t){t=t??{};let e=t.onEnd,o=new b,n,c,u,y=S(),l=async()=>{try{return o.isEmpty()?u?{done:!0}:await new Promise((r,h)=>{c=w=>{c=null,o.push(w);try{r(s(o))}catch(i){h(i)}return n}}):s(o)}finally{o.isEmpty()&&queueMicrotask(()=>{y.resolve(),y=S()})}},d=r=>c!=null?c(r):(o.push(r),n),p=r=>(o=new b,c!=null?c({error:r}):(o.push({error:r}),n)),m=r=>{if(u)return n;if(t?.objectMode!==!0&&r?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return d({done:!1,value:r})},f=r=>u?n:(u=!0,r!=null?p(r):d({done:!0})),E=()=>(o=new b,f(),{done:!0}),T=r=>(f(r),{done:!0});if(n={[Symbol.asyncIterator](){return this},next:l,return:E,throw:T,push:m,end:f,get readableLength(){return o.size},onEmpty:async r=>{let h=r?.signal;if(h?.throwIfAborted(),o.isEmpty())return;let w,i;h!=null&&(w=new Promise((K,D)=>{i=()=>{D(new N)},h.addEventListener("abort",i)}));try{await Promise.race([y.promise,w])}finally{i!=null&&h!=null&&h?.removeEventListener("abort",i)}}},e==null)return n;let a=n;return n={[Symbol.asyncIterator](){return this},next(){return a.next()},throw(r){return a.throw(r),e!=null&&(e(r),e=void 0),{done:!0}},return(){return a.return(),e!=null&&(e(),e=void 0),{done:!0}},push:m,end(r){return a.end(r),e!=null&&(e(r),e=void 0),n},get readableLength(){return a.readableLength},onEmpty:r=>a.onEmpty(r)},n}var _="/perf/1.0.0";var x=class{log;protocol;components;started;databuf;writeBlockSize;maxInboundStreams;maxOutboundStreams;runOnTransientConnection;constructor(t,e={}){this.components=t,this.log=t.logger.forComponent("libp2p:perf"),this.started=!1,this.protocol=e.protocolName??_,this.writeBlockSize=e.writeBlockSize??65536,this.databuf=new ArrayBuffer(this.writeBlockSize),this.maxInboundStreams=e.maxInboundStreams??1,this.maxOutboundStreams=e.maxOutboundStreams??1,this.runOnTransientConnection=e.runOnTransientConnection??!1}async start(){await this.components.registrar.handle(this.protocol,t=>{this.handleMessage(t).catch(e=>{this.log.error("error handling perf protocol message",e)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams,runOnTransientConnection:this.runOnTransientConnection}),this.started=!0}async stop(){await this.components.registrar.unhandle(this.protocol),this.started=!1}isStarted(){return this.started}async handleMessage(t){let{stream:e}=t;try{let o=this.writeBlockSize,n;for await(let u of e.source)n==null&&(n=Number(u.getBigUint64(0,!1)));if(n==null)throw new Error("bytesToSendBack was not set");let c=new Uint8Array(this.databuf,0,this.databuf.byteLength);await e.sink(async function*(){for(;n>0;){let u=o;u>n&&(u=n),n=n-u,yield c.subarray(0,u)}}())}catch(o){e.abort(o)}}async*measurePerformance(t,e,o,n={}){this.log("opening stream on protocol %s to %a",this.protocol,t);let c=new Uint8Array(this.databuf),u=this.writeBlockSize,y=Date.now(),l=Date.now(),d=await this.components.connectionManager.openConnection(t,{...n,force:n.reuseExistingConnection!==!0});this.log("opened connection after %d ms",Date.now()-l),l=Date.now();let p=await d.newStream(this.protocol,n);this.log("opened stream after %d ms",Date.now()-l),l=Date.now();let m=0,f=0,E=Date.now();new DataView(this.databuf).setBigUint64(0,BigInt(o),!1),this.log("sending %i bytes to %p",e,d.remotePeer);try{let a=B({objectMode:!0});p.sink(async function*(){for(yield c.subarray(0,8);e>0;){let i=u;i>e&&(i=e),yield c.subarray(0,i),e-=i,Date.now()-l>1e3&&(a.push({type:"intermediary",timeSeconds:(Date.now()-l)/1e3,uploadBytes:m,downloadBytes:0}),l=Date.now(),m=0),m+=i,f+=i}a.end()}()).catch(i=>{a.end(i)}),yield*a,this.log("upload complete after %d ms",Date.now()-E);let r=0;l=Date.now();let h=0,w=Date.now();for await(let i of p.source)Date.now()-l>1e3&&(yield{type:"intermediary",timeSeconds:(Date.now()-l)/1e3,uploadBytes:0,downloadBytes:r},l=Date.now(),r=0),r+=i.byteLength,h+=i.byteLength;if(this.log("download complete after %d ms",Date.now()-w),h!==o)throw new Error(`Expected to receive ${o} bytes, but received ${h}`);yield{type:"final",timeSeconds:(Date.now()-y)/1e3,uploadBytes:f,downloadBytes:h},this.log("performed %s to %p",this.protocol,d.remotePeer),await p.close()}catch(a){throw this.log("error sending %d/%d bytes to %p: %s",f,e,d.remotePeer,a),p.abort(a),a}}};function X(s={}){return t=>new x(t,s)}return R(j);})();
return Libp2PPerf}));
